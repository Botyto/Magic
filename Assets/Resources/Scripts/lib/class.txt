--Main tables
if FirstLoad then
	FinalClasses = { }
end
ClassDefs = { }

Class = { }
setmetatable(Class, {
	__newindex = function(t, name, def)
		assertf(rawget(ClassDefs, name) == nil, "Class '%s' already defined.", name)
		ClassDefs[name] = def
		rawset(_G, name, def)
	end,
})

--Utilty functions
function IsKindOf(obj, class)
	return obj and obj.__ancestors[class]
end

--Building classes
local NonInheritedMembers = {
	__inherit = true,
	__ancestors = true,
}

local function BuildSingleClass(name)
	--get class definition
	local classdef = ClassDefs[name]
	--if definition is not found - then the class has already been built
	if not classdef then
		return FinalClasses[name]
	end
	--mark this class as built
	ClassDefs[name] = nil

	--find the actual class table
	local class = FinalClasses[name] or { }
	FinalClasses[name] = class
	rawset(_G, name, class)
	--if there was an old table of this class - clear all it's members first'
	setmetatable(class, nil)
	for member in pairs(class) do
		class[member] = nil
	end

	--define builtin members
	class.class = name --class name
	function class:HasMember(member) --has member check
		for ancestor in pairs(self.__ancestors) do --TODO optimize
			if rawget(FinalClasses[ancestor], member) ~= nil then
				return true
			end
		end
		return false
	end
	class.IsKindOf = IsKindOf --is kind of check
	function class:new(obj) --new object method
		obj = obj or { }
		setmetatable(obj, class)
		return obj
	end
	class.__index = class.__index or class
	class.__newindex = class.__newindex or function(obj, member, value) --newindex metamethod
		if not obj:HasMember(member) then
			errorf("Writing undefined member '%s.%s'", name, member)
		end
		rawset(obj, member, value)
	end

	--build parent class
	class.__inherit = classdef.__inherit or false
	if class.__inherit then
		BuildSingleClass(class.__inherit)
	end

	--fill in the ancestors list
	class.__ancestors = { [name] = true }
	local next_ancestor = class.__inherit
	while next_ancestor do
		if not class.__ancestors[next_ancestor] then
			class.__ancestors[next_ancestor] = true
			next_ancestor = FinalClasses[next_ancestor].__inherit
		elseif next_ancestor == name then
			errorf("Cyclic inheritance in class '%s'", name)
		end
	end

	--write all classdef fields into class tablee
	--this order allows overwriting builtin members
	for member,value in pairs(classdef) do
		class[member] = value
	end

	--resolve inheritance
	if class.__inherit then
		local parent = FinalClasses[class.__inherit]
		if parent then
			setmetatable(class, { __index = parent })
		else
			errorf("'%s' inherits non-existing class '%s'", name, class.__inherit)
		end
	else
		setmetatable(class, class)
	end

	return class
end

function BuildClasses()
	for name in pairs(FinalClasses) do
		rawset(_G, name, nil)
		if not ClassDefs[name] then
			rawset(FinalClasses, name, nil)
		end
	end

	RaiseEvent("PreBuildClasses", ClassDefs)
	for name in pairs(ClassDefs) do
		BuildSingleClass(name)
	end
	RaiseEvent("PostBuildClasses")
end
